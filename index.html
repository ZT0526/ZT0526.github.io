
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ZT0526">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://zt0526.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:zt0526.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/22/five/" title="IOS播放GIF动画的方式及手动实现gif动画的播放" itemprop="url">IOS播放GIF动画的方式及手动实现gif动画的播放</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ZT0526" target="_blank" itemprop="author">ZT0526</a>
		
  <p class="article-time">
    <time datetime="2017-08-22T03:49:21.000Z" itemprop="datePublished"> Published 2017-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>###写在前面:<br>   视频或者动画其实就是多个帧（多个画面）组合起来形成的，这个帧数至少要达到30帧每秒(30fps)，看起来才会觉得是正常的，视觉上看起来才是动的</p>
<p>##方法一：UIView播放动画<br>      使用UIView的动画来播放gif，原理是将gif所使用的所有图片做成一个动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UIImageView *view = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</div><div class="line">view.animationImages= @[[UIImage imageNamed:@&quot;yaoyiyao1.jpg&quot;],</div><div class="line">                        [UIImage imageNamed:@&quot;yaoyiyao2.jpg&quot;],</div><div class="line">                       [UIImage imageNamed:@&quot;yaoyiyao3.jpg&quot;],</div><div class="line">                        [UIImage imageNamed:@&quot;yaoyiyao4.jpg&quot;],</div><div class="line">                       [UIImage imageNamed:@&quot;yaoyiyao5.jpg&quot;]];</div><div class="line">view.animationDuration = 0.45;</div><div class="line">view.animationRepeatCount = 0;</div><div class="line">[self.view addSubview:view];</div><div class="line">[view startAnimating];</div></pre></td></tr></table></figure>
<p>这种方法确实能够让gif动起来，但是会使用多张图片，若果我们是根据gif的图片链接来播放动画的话，这种方式就不行了。并且该方式不能完全模拟出gif的效果(比如gif的某处会有停顿一下，这个停顿的多少  这里就不好模拟了)。</p>
<p>##方法二：UIWebView播放动画<br>    UIWebView来播放动画比较省事儿，可以直接播放本地的gif文件，也可以直接播放gif网络图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//得到图片的路径</div><div class="line">  NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;yaoyiyao&quot; ofType:@&quot;gif&quot;];</div><div class="line">  //将图片转为NSData</div><div class="line">  NSData *gifData = [NSData dataWithContentsOfFile:path];</div><div class="line">  //创建一个webView，添加到界面</div><div class="line">  UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(self.view.width - 200,self.view.height -  200, 160, 105)];</div><div class="line">  [self.view addSubview:webView];</div><div class="line">  //自动调整尺寸</div><div class="line">  webView.scalesPageToFit = YES;</div><div class="line">  //禁止滚动</div><div class="line">  webView.scrollView.scrollEnabled = NO;</div><div class="line">  //设置透明效果</div><div class="line">  webView.backgroundColor = [UIColor clearColor];</div><div class="line">  webView.opaque = 0;</div><div class="line">  //加载数据</div><div class="line">  [webView loadData:gifData MIMEType:@&quot;image/gif&quot; textEncodingName:nil baseURL:nil];</div></pre></td></tr></table></figure></p>
<p>播放gif网络图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url];</div><div class="line">[_webView loadRequest:request];</div></pre></td></tr></table></figure></p>
<p>这种方法来播放gif虽然能很好的播放gif，但是也有一些缺点。特别是在gif展示的大小上达不到很好的效果，当webView比较小的时候，gif比较大的时候，不能完整的将gif展示出来</p>
<p>##方法三：使用SDWebImage<br>   SDWebImage是一个很强大的三方库，能够异步的加载图片并提供了完整的图片的下载、存储、等于图片下载相关的功能服务，基本上很多应用都会使用该三方库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.bgImageView sd_setImageWithURL:[NSURL URLWithString:self.model.picHomeUrl]];</div></pre></td></tr></table></figure></p>
<p>这种方式也会有缺陷，有时候下载下来的gif动不了！居然动不了！。(有可能是我使用的SDWebImage不是最新的)</p>
<p>##方法四：使用YLGIFImage<br><a href="https://github.com/liyong03/YLGIFImage" target="_blank" rel="external">YLGIFImage</a>某个外国人写的三方库，该库中就两个类YLGImageView、YLGIFImage。是专门用来播放gif的。<br>首先使用NSURLSession下载网络图片，下载完成后再在主线程中去展示gif<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> NSURL *url = [NSURL URLWithString:self.model.picHomeUrl];</div><div class="line">        NSURLRequest *reque = [NSURLRequest requestWithURL:url];</div><div class="line">        NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration]];</div><div class="line">        NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:reque completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123;</div><div class="line">            NSLog(@&quot;%@&quot;, location);</div><div class="line">            if(error)&#123;</div><div class="line">                [self performSelectorOnMainThread:@selector(handleError:) withObject:error waitUntilDone:YES];</div><div class="line">            &#125;else&#123;</div><div class="line">                NSData *data = [NSData dataWithContentsOfURL:location];</div><div class="line">                [self performSelectorOnMainThread:@selector(setBgViewData:)</div><div class="line">                                       withObject:data</div><div class="line">                                    waitUntilDone:YES];</div><div class="line">            &#125;</div><div class="line">        &#125;];  </div><div class="line">        [task resume];  </div><div class="line"></div><div class="line">- (void)setBgViewData:(NSData *)data&#123;</div><div class="line">    [MBProgressHUD hideAllHUDsForView:self.bgImageView animated:YES];</div><div class="line">    [UIView animateWithDuration:0.2f animations:^&#123;</div><div class="line">       self.bgImageView.image = [YLGIFImage imageWithData:data];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)handleError:(NSError *)error&#123;</div><div class="line">    [MBProgressHUD hideAllHUDsForView:self.bgImageView animated:YES];</div></pre></td></tr></table></figure></p>
<p>使用这种方法能完美解决gif播放的问题。我在编译的时候遇到过这个地方报错，将 [(UIImage <em>)[self.images objectAtIndex:0] size];改成 [(UIImage </em>)[self.images objectAtIndex:0] size];就可以了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-571cc10fe5172a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="55EA5F7F-B633-4EB0-94A3-2914050AB7BE.png"></p>
<p>但是使用YLGIFImage的时候  会在ios7系统上出现偶现的崩溃现象。所以这种方法还是不怎么可取。😔</p>
<p>##方法五：使用YYWebImage<br><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a>  是一个异步图片加载框架 (YYKit 组件之一).具有诸多优点。<br>支持异步的图片加载， HTTP 和本地文件。支持 GIF、APNG、WebP 动画（动态缓存，低内存占用）。适用于ios6及以上的系统，经过大量的使用，稳定性较高.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">从 URL 加载图片</div><div class="line">// 加载网络图片</div><div class="line">imageView.yy_imageURL = [NSURL URLWithString:@&quot;http://github.com/logo.png&quot;];</div><div class="line"></div><div class="line">// 加载本地图片</div><div class="line">imageView.yy_imageURL = [NSURL fileURLWithPath:@&quot;/tmp/logo.png&quot;];</div><div class="line">加载动图</div><div class="line"></div><div class="line">// 只需要把 `UIImageView` 替换为 `YYAnimatedImageView` 即可。</div><div class="line">UIImageView *imageView = [YYAnimatedImageView new];</div><div class="line">imageView.yy_imageURL = [NSURL URLWithString:@&quot;http://github.com/ani.webp&quot;];</div><div class="line">渐进式图片加载</div><div class="line"></div><div class="line">// 渐进式：边下载边显示</div><div class="line">[imageView yy_setImageWithURL:url options:YYWebImageOptionProgressive];</div><div class="line"></div><div class="line">// 渐进式加载，增加模糊效果和渐变动画 （见本页最上方的GIF演示）</div><div class="line">[imageView yy_setImageWithURL:url options:YYWebImageOptionProgressiveBlur ｜ YYWebImageOptionSetImageWithFadeAnimation];</div><div class="line">加载、处理图片</div><div class="line"></div><div class="line">// 1. 下载图片</div><div class="line">// 2. 获得图片下载进度</div><div class="line">// 3. 调整图片大小、加圆角</div><div class="line">// 4. 显示图片时增加一个淡入动画，以获得更好的用户体验</div><div class="line"></div><div class="line">[imageView yy_setImageWithURL:url</div><div class="line">    placeholder:nil</div><div class="line">    options:YYWebImageOptionSetImageWithFadeAnimation</div><div class="line">    progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</div><div class="line">        progress = (float)receivedSize / expectedSize;</div><div class="line">    &#125;</div><div class="line">    transform:^UIImage *(UIImage *image, NSURL *url) &#123;</div><div class="line">        image = [image yy_imageByResizeToSize:CGSizeMake(100, 100) contentMode:UIViewContentModeCenter];</div><div class="line">        return [image yy_imageByRoundCornerRadius:10];</div><div class="line">    &#125;</div><div class="line">    completion:^(UIImage *image, NSURL *url, YYWebImageFromType from, YYWebImageStage stage, NSError *error) &#123;</div><div class="line">        if (from == YYWebImageFromDiskCache) &#123;</div><div class="line">            NSLog(@&quot;load from disk cache&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">图片缓存</div><div class="line"></div><div class="line">YYImageCache *cache = [YYWebImageManager sharedManager].cache;</div><div class="line"></div><div class="line">// 获取缓存大小</div><div class="line">cache.memoryCache.totalCost;</div><div class="line">cache.memoryCache.totalCount;</div><div class="line">cache.diskCache.totalCost;</div><div class="line">cache.diskCache.totalCount;</div><div class="line"></div><div class="line">// 清空缓存</div><div class="line">[cache.memoryCache removeAllObjects];</div><div class="line">[cache.diskCache removeAllObjects];</div><div class="line"></div><div class="line">// 清空磁盘缓存，带进度回调</div><div class="line">[cache.diskCache removeAllObjectsWithProgressBlock:^(int removedCount, int totalCount) &#123;</div><div class="line">    // progress</div><div class="line">&#125; endBlock:^(BOOL error) &#123;</div><div class="line">    // end</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>手动添加的时候 如果不使用webp  除了将YYWebImage拖入项目中外，还需要将#define YYIMAGE_WEBP_ENABLED 1改为#define YYIMAGE_WEBP_ENABLED 0   我觉得这是一个很机智的写法, 有的类文件中通过判断这个宏定义来确定是否编译支持webp的方法</p>
<p>我会在下一篇文章中探讨一下 ios加载gif动画的原理</p>
<p>这里是讲解ios播放gif动画原理的代码<a href="https://github.com/ZT0526/Gif-Animation" target="_blank" rel="external">https://github.com/ZT0526/Gif-Animation</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/22/fourthArticle/" title="IOS自定义相机,使用AVFoundation(附实现部分腾讯水印相机功能demo)" itemprop="url">IOS自定义相机,使用AVFoundation(附实现部分腾讯水印相机功能demo)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ZT0526" target="_blank" itemprop="author">ZT0526</a>
		
  <p class="article-time">
    <time datetime="2017-08-22T03:48:39.000Z" itemprop="datePublished"> Published 2017-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在项目中当我们遇到拍照的功能模块的时候，如果仅仅是用来拍照，系统提供的UIImagePickerController足够用来完成我们的任务。但是当我们的应用场景稍稍复杂点的时候，如要实现类似水印相机、美颜相机的时候，UIImagePickerController就有点力不从心了，需要自己去diy一个自定义相机。</p>
<p>UIImagePickerController使用起来比较简单易用，拍照，录制视频、控制闪光灯，前后摄像头的切换一应俱全。但是相机支持ui界面的自定义并不好(虽然可以支持自定义)，在不同的系统下相机的功能界面还有所差别。</p>
<p>以水印相机为例，在水印相机中我们需要能够让水印模式实时的显示在相机的取景框中，而且水印模式还要可以左右滑动切换，在横屏的时候水印也要跟着横屏，还要有放大缩小镜头的以及点击屏幕能够聚焦等功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-12ea92d5ec98730c.gif?imageMogr2/auto-orient/strip" alt="腾讯水印相机.gif"></p>
<p>当然有人可能会想，将水印模式分成一个视图层然后放到相机的最上层不就行了吗？当然是不行的，首先UIImagePickerController在不同系统中的封装是略微不一样的，ui界面有所差别，界面不能够统一，即便是现在花了很过代码一个系统一个系统的适配，也很难保证以后不出问题，其次是手势的识别也有问题，即便是对手势进行了拦截处理，也不能解决，说白了也就是不是自己封装的东西，难以得到完美的掌控。</p>
<p>下面就开始自定义一个相机，并实现拍照、取消、闪光灯控制、前后摄像头控制、聚焦、放大缩小、拍照后预览、重拍、使用照片等功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) ZTImagePickerOverLayView  *overlayView;//预览图层</div><div class="line"></div><div class="line">@property (nonatomic) dispatch_queue_t sessionQueue;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AVCaptureSession* session;//用于捕捉视频和音频,协调视频和音频的输入和输出流</div><div class="line"></div><div class="line">@property (nonatomic, strong) AVCaptureDeviceInput* videoInput;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AVCaptureStillImageOutput* stillImageOutput;//输出静态影像</div><div class="line"></div><div class="line">@property (nonatomic, strong) AVCaptureDevice             *device;//主要用来获取iphone一些关于相机设备的属性</div><div class="line">@property (nonatomic, strong) AVCaptureVideoPreviewLayer* previewLayer;//预览图层layer</div></pre></td></tr></table></figure></p>
<p>这里将相机的控件以及相机的实时显示的图层放在一个视图类ZTImagePickerOverLayView中，拍完照后的图层放在另外一个类ZTImagePickerPreImageView中,各个视图间的协调及部分逻辑放在控制器中ZTImagePickerController。封装完整个相机不过用了几百行代码。</p>
<p>1.初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">self.session = [[AVCaptureSession alloc] init];</div><div class="line">   [self.session setSessionPreset:AVCaptureSessionPresetPhoto];</div><div class="line">   </div><div class="line">   NSError *error;</div><div class="line">   </div><div class="line">   self.device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">   </div><div class="line">   </div><div class="line">   self.videoInput = [[AVCaptureDeviceInput alloc] initWithDevice:self.device error:&amp;error];</div><div class="line">  </div><div class="line">   self.stillImageOutput = [[AVCaptureStillImageOutput alloc] init];</div><div class="line">   //输出设置。AVVideoCodecJPEG   输出jpeg格式图片</div><div class="line">   NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:AVVideoCodecJPEG,AVVideoCodecKey, nil];</div><div class="line">   [self.stillImageOutput setOutputSettings:outputSettings];</div><div class="line">   </div><div class="line">   if ([self.session canAddInput:self.videoInput]) &#123;</div><div class="line">       [self.session addInput:self.videoInput];</div><div class="line">   &#125;</div><div class="line">   if ([self.session canAddOutput:self.stillImageOutput]) &#123;</div><div class="line">       [self.session addOutput:self.stillImageOutput];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //初始化预览图层</div><div class="line">   self.previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.session];</div><div class="line">   [self.previewLayer setVideoGravity:AVLayerVideoGravityResizeAspect];</div><div class="line">   NSLog(@&quot;%f&quot;,ScreenWidth);</div><div class="line">   self.previewLayer.frame = CGRectMake(0, 0,ScreenWidth, ScreenHeight);</div><div class="line">   self.preview = [[ZTImagePickerOverLayView alloc] init];</div><div class="line">   self.preview.frame = CGRectMake(0, 0, ScreenWidth, ScreenHeight);</div><div class="line">   [self.preview layoutSubviews];</div><div class="line">   [self.preview.layer addSublayer:self.previewLayer];</div><div class="line">   [self.view addSubview:self.preview];</div><div class="line">   </div><div class="line">   //添加顶部以及底部的自定义工具条</div><div class="line">   [self.view addSubview:self.preview.topbar];</div><div class="line">   [self.view addSubview:self.preview.buttomBar];</div><div class="line">   self.preview.topbar.frame = CGRectMake(0, 0, self.view.width, 64 * ScreenWidth/320.0);</div><div class="line">   self.preview.buttomBar.frame = CGRectMake(0, self.view.height - 70 * ScreenWidth/320.0 , self.view.width, 70* ScreenWidth/320.0);</div><div class="line">   [self.preview layoutSubviews];</div><div class="line">   //设置闪关灯模式</div><div class="line">   if(self.device.isFlashAvailable)</div><div class="line">       [self.preview setFlashModel:self.device.flashMode];</div><div class="line">   else&#123;</div><div class="line">       self.preview.flashButton.hidden = YES;</div><div class="line">       self.preview.cameraSwitchButton.hidden = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //设置拍照后预览图层</div><div class="line">   self.preImageView = [[ZTImagePickerPreImageView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight)];</div><div class="line">   [self.preImageView layoutSubviews];</div><div class="line">   self.preImageView.hidden = YES;</div><div class="line">   [self.view addSubview:self.preImageView];</div></pre></td></tr></table></figure></p>
<p>2.添加手势<br>给预览层添加捏合手势控制放大缩小,添加点击手势来聚焦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self</div><div class="line">                                                                               action:@selector(handlePinchGesture:)];</div><div class="line">   pinch.delegate = self;</div><div class="line">   [self.preview addGestureRecognizer:pinch];</div><div class="line">   </div><div class="line">   </div><div class="line">   UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self</div><div class="line">                                                                         action:@selector(focusAction:)];</div><div class="line">   [self.preview addGestureRecognizer:tap];</div></pre></td></tr></table></figure></p>
<p>3.给控件添加响应事件<br>闪光灯打开、关闭、自动，摄像头切换、取消、拍照、重新拍照、使用照片等按钮添加响应事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[self.preview.cameraSwitchButton addTarget:self action:@selector(switchCameraSegmentedControlClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    [self.preview.flashAutoButton addTarget:self action:@selector(flashButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    [self.preview.flashOpeanButton addTarget:self action:@selector(flashButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    [self.preview.flashCloseButton addTarget:self action:@selector(flashButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    </div><div class="line">    [self.preview.takePictureButton addTarget:self action:@selector(takePhotoButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    </div><div class="line">    [self.preview.cancelButton addTarget:self action:@selector(cancelButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    </div><div class="line">    [self.preImageView.reTakeButton addTarget:self action:@selector(retakeButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">    [self.preImageView.useImageButton addTarget:self action:@selector(useImageButtonClick:) forControlEvents:UIControlEventTouchUpInside];</div></pre></td></tr></table></figure></p>
<p>4.闪光灯控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)flashButtonClick:(UIButton *)sender &#123;</div><div class="line">    //[self.preview reSetTopbar];</div><div class="line">    [self.preview chosedFlashButton:sender];</div><div class="line">    </div><div class="line">    NSLog(@&quot;flashButtonClick&quot;);</div><div class="line">    </div><div class="line">    AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">    </div><div class="line">    //修改前必须先锁定</div><div class="line">    [device lockForConfiguration:nil];</div><div class="line">    //必须判定是否有闪光灯，否则如果没有闪光灯会崩溃</div><div class="line">    if ([device hasFlash]) &#123;</div><div class="line">        if([sender.titleLabel.text isEqualToString:@&quot;打开&quot;])&#123;</div><div class="line">            if([device isFlashModeSupported:AVCaptureFlashModeOn])</div><div class="line">                [device setFlashMode:AVCaptureFlashModeOn];</div><div class="line">        &#125;else if ([sender.titleLabel.text isEqualToString:@&quot;自动&quot;])&#123;</div><div class="line">            if([device isFlashModeSupported:AVCaptureFlashModeAuto])</div><div class="line">                [device setFlashMode:AVCaptureFlashModeAuto];</div><div class="line">            </div><div class="line">        &#125;else if ([sender.titleLabel.text isEqualToString:@&quot;关闭&quot;])&#123;</div><div class="line">            if([device isFlashModeSupported:AVCaptureFlashModeOff])</div><div class="line">                [device setFlashMode:AVCaptureFlashModeOff];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        </div><div class="line">        NSLog(@&quot;设备不支持闪光灯&quot;);</div><div class="line">    &#125;</div><div class="line">    [device unlockForConfiguration];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.前后摄像头切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)switchCameraSegmentedControlClick:(id)sender &#123;</div><div class="line">    </div><div class="line">    //NSLog(@&quot;%ld&quot;,(long)sender.selectedSegmentIndex);</div><div class="line">    </div><div class="line">    AVCaptureDevicePosition desiredPosition;</div><div class="line">    AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</div><div class="line">    if (isUsingFrontFacingCamera)&#123;</div><div class="line">        </div><div class="line">        if(device.isFlashAvailable) self.preview.flashButton.hidden = NO;</div><div class="line">        desiredPosition = AVCaptureDevicePositionBack;</div><div class="line">        </div><div class="line">    &#125;else&#123;</div><div class="line">        desiredPosition = AVCaptureDevicePositionFront;</div><div class="line">        [self.preview reSetTopbar];</div><div class="line">        self.preview.flashButton.hidden = YES;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    for (AVCaptureDevice *d in [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]) &#123;</div><div class="line">        if ([d position] == desiredPosition) &#123;</div><div class="line">            [self.previewLayer.session beginConfiguration];</div><div class="line">            AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:d error:nil];</div><div class="line">            for (AVCaptureInput *oldInput in self.previewLayer.session.inputs) &#123;</div><div class="line">                [[self.previewLayer session] removeInput:oldInput];</div><div class="line">            &#125;</div><div class="line">            [self.previewLayer.session addInput:input];</div><div class="line">            [self.previewLayer.session commitConfiguration];</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    isUsingFrontFacingCamera = !isUsingFrontFacingCamera;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.拍照<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)takePhotoButtonClick:(id )sender&#123;</div><div class="line">    </div><div class="line">    AVCaptureConnection *stillImageConnection = [self.stillImageOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class="line">    UIDeviceOrientation curDeviceOrientation = [[UIDevice currentDevice] orientation];</div><div class="line">    AVCaptureVideoOrientation avcaptureOrientation = [self avOrientationForDeviceOrientation:curDeviceOrientation];</div><div class="line">    [stillImageConnection setVideoOrientation:avcaptureOrientation];</div><div class="line">    [stillImageConnection setVideoScaleAndCropFactor:self.effectiveScale];</div><div class="line">    </div><div class="line">    [self.stillImageOutput captureStillImageAsynchronouslyFromConnection:stillImageConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) &#123;</div><div class="line">        </div><div class="line">        NSData *jpegData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer];</div><div class="line">        self.imageData = jpegData;</div><div class="line">        CFDictionaryRef attachments = CMCopyDictionaryOfAttachments(kCFAllocatorDefault,</div><div class="line">                                                                    imageDataSampleBuffer,</div><div class="line">                                                                    kCMAttachmentMode_ShouldPropagate);</div><div class="line">        UIImage *image = [UIImage imageWithData:jpegData];</div><div class="line">        [self waterMarkFixed];</div><div class="line">        self.preImageView.imageView.image = image;</div><div class="line">        [self.preview hiddenSelfAndBars:YES];</div><div class="line">        self.preImageView.hidden = NO;</div><div class="line">        </div><div class="line">        ALAuthorizationStatus author = [ALAssetsLibrary authorizationStatus];</div><div class="line">            if (author == ALAuthorizationStatusRestricted || author ==ALAuthorizationStatusDenied)&#123;</div><div class="line">                    //无权限</div><div class="line">                    return ;</div><div class="line">                &#125;</div><div class="line">        //保存到相册</div><div class="line">//            ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</div><div class="line">//            [library writeImageDataToSavedPhotosAlbum:jpegData metadata:(__bridge id)attachments completionBlock:^(NSURL *assetURL, NSError *error) &#123;</div><div class="line">//        </div><div class="line">//            &#125;];</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    if([self.delegate respondsToSelector:@selector(imagePickerControllerTakePhoto:)])</div><div class="line">        [self.delegate imagePickerControllerTakePhoto:self];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7.放大缩小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)handlePinchGesture:(UIPinchGestureRecognizer *)recognizer&#123;</div><div class="line">    </div><div class="line">    BOOL allTouchesAreOnThePreviewLayer = YES;</div><div class="line">    NSUInteger numTouches = [recognizer numberOfTouches], i;</div><div class="line">    for ( i = 0; i &lt; numTouches; ++i ) &#123;</div><div class="line">        CGPoint location = [recognizer locationOfTouch:i inView:self.preview];</div><div class="line">        CGPoint convertedLocation = [self.previewLayer convertPoint:location fromLayer:self.previewLayer.superlayer];</div><div class="line">        if ( ! [self.previewLayer containsPoint:convertedLocation] ) &#123;</div><div class="line">            allTouchesAreOnThePreviewLayer = NO;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if ( allTouchesAreOnThePreviewLayer ) &#123;</div><div class="line">        </div><div class="line">        </div><div class="line">        self.effectiveScale = self.beginGestureScale * recognizer.scale;</div><div class="line">        if (self.effectiveScale &lt; 1.0)&#123;</div><div class="line">            self.effectiveScale = 1.0;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        CGFloat maxScaleAndCropFactor = [[self.stillImageOutput connectionWithMediaType:AVMediaTypeVideo] videoMaxScaleAndCropFactor];</div><div class="line">        </div><div class="line">        </div><div class="line">        if (self.effectiveScale &gt; maxScaleAndCropFactor)</div><div class="line">            self.effectiveScale = maxScaleAndCropFactor;</div><div class="line">        </div><div class="line">        [CATransaction begin];</div><div class="line">        [CATransaction setAnimationDuration:.025];</div><div class="line">        [self.previewLayer setAffineTransform:CGAffineTransformMakeScale(self.effectiveScale, self.effectiveScale)];</div><div class="line">        [CATransaction commit];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8.照片方向修正<br>拍完照的时候，拍出的照片你会发现呈现的方向不对，需要对照片的方向进行修正。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> AVCaptureVideoOrientation avcaptureOrientation = [self avOrientationForDeviceOrientation:curDeviceOrientation];</div><div class="line">    [stillImageConnection setVideoOrientation:avcaptureOrientation];</div><div class="line"></div><div class="line">- (AVCaptureVideoOrientation)avOrientationForDeviceOrientation:(UIDeviceOrientation)deviceOrientation</div><div class="line">&#123;</div><div class="line">    AVCaptureVideoOrientation result = (AVCaptureVideoOrientation)deviceOrientation;</div><div class="line">    if ( deviceOrientation == UIDeviceOrientationLandscapeLeft )</div><div class="line">        result = AVCaptureVideoOrientationLandscapeRight;</div><div class="line">    else if ( deviceOrientation == UIDeviceOrientationLandscapeRight )</div><div class="line">        result = AVCaptureVideoOrientationLandscapeLeft;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是如果想要拍完照的效果和UIimagePickerController的效果一样，即在横屏下拍完照，照片要旋转显示并且显示的小一些，那么就要对拍完照预览图层进行修改。</p>
<p>图片</p>
<p>在预览图层中修改imageview的大小。(这部分代码我并没有加到demo中，如果想实现拍完照后照片的方向与系统相机的一样，可以在ZTImagePickerPreImageView中加上)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)changeImageViewFrameIfNeeded:(UIDeviceOrientation)orientation&#123;</div><div class="line">    if(orientation == UIDeviceOrientationLandscapeLeft || orientation == UIDeviceOrientationLandscapeRight)&#123;</div><div class="line">    </div><div class="line">        self.imageView.frame = CGRectMake(0, 0, self.width, 240 * [UIScreen mainScreen].bounds.size.width / 320.0);</div><div class="line">        self.imageView.centerY = self.height / 2.0;</div><div class="line">    &#125;else&#123;</div><div class="line">        _imageView.frame = CGRectMake(0, 0, self.width, 418 * [UIScreen mainScreen].bounds.size.width / 320.0);</div><div class="line">        _imageView.centerY = self.height / 2.0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅仅是这样还不够，还要对设备方向的获取进行改进。<br>通常我们获取设备方向是通过[[UIDevice currentDevice] orientation] 或者通过[UIApplication sharedApplication].statusBarOrientation的方式来获取。但这两种方式有一个缺点，在竖排方向开关关闭的时候，获取到的方向是正确的，在开关打开的时候获取到的方向是竖直方向，在横屏等情况下获取的方向不正确。这时候就要通过CMMotionManager来获取方向了。(下面这段代码也没有加到demo中，如果有这样的功能需求，可以在ZTImagePickerController中加上这段代码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)p_startMotionManager&#123;</div><div class="line">    self.deviceOrientation = UIDeviceOrientationPortrait;</div><div class="line">    if (_motionManager == nil) &#123;</div><div class="line">        _motionManager = [[CMMotionManager alloc] init];</div><div class="line">    &#125;</div><div class="line">    _motionManager.deviceMotionUpdateInterval = 1/15.0;</div><div class="line">    if (_motionManager.deviceMotionAvailable) &#123;</div><div class="line">        NSLog(@&quot;Device Motion Available&quot;);</div><div class="line">        [_motionManager startDeviceMotionUpdatesToQueue:[NSOperationQueue currentQueue]</div><div class="line">                                            withHandler: ^(CMDeviceMotion *motion, NSError *error)&#123;</div><div class="line">                                                [self performSelectorOnMainThread:@selector(handleDeviceMotion:) withObject:motion waitUntilDone:YES];</div><div class="line">                                                </div><div class="line">                                            &#125;];</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;No device motion on device.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_stopMonotionManager&#123;</div><div class="line">    [_motionManager stopDeviceMotionUpdates];</div><div class="line">    _motionManager = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二、添加水印<br>如果要实现类似腾讯的水印相机形式的水印，需要对水印专门做一个图层来进行管理。将水印图层放在相机的最上层就可以实时看到水印了，并且可以左右切换水印。这里使用scrollview来容纳每种水印样式，如果水印样式比较多当然可以使用collectionView来容纳。</p>
<p>为了让水印图层的手势(scrollView的左右滑动，每种水印样式视图中的控件响应手势)响应不与相机图层的手势响应不冲突，在水印图层可以将手势进行拦截，根据实际情况来返回响应手势的视图控件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">这里的代码根据实际情况修改</div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</div><div class="line">    </div><div class="line">    UIView *view = [super hitTest:point withEvent:event];</div><div class="line">    </div><div class="line">    CGPoint tempPoint = [self.reportView convertPoint:point fromView:self];</div><div class="line">    if(CGRectContainsPoint(self.reportView.reportTypeLb.frame, tempPoint))&#123;</div><div class="line">        view = self.reportView.reportTypeLb;</div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSInteger left = 0,top = 0, height = 0,width = self.contentSize.width;</div><div class="line">     height = MAX(self.reportView.xmNameLb.top, self.handleProblemView.userLb.top);</div><div class="line">    if([UIDevice currentDevice].orientation == UIDeviceOrientationLandscapeLeft)&#123;</div><div class="line">        left = self.height - height;</div><div class="line">        width = self.width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if(CGRectContainsPoint(CGRectMake(left, top, width, height), point))&#123;</div><div class="line">            view = [self.superview.subviews objectAtIndex:0];</div><div class="line">            view = [view hitTest:point withEvent:event];</div><div class="line">        &#125;else&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拍完照选择好水印样式后，将水印样式用的空间绘制到照片上，就形成了水印照片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)markedImageWithType:(XBWaterMark )waterMarkType date:(NSDate *)date user:(NSString *)user placLocation:(ZTLocationModel *)locationModel withPhone:(NSString *)phone xmType:(NSString *)xmType&#123;</div><div class="line">    </div><div class="line">    if (self.size.width == 0.0 || self.size.height == 0.0) return nil;</div><div class="line">    </div><div class="line">    UIImage *defaultImage = nil;</div><div class="line">    </div><div class="line">    CGFloat scale = [UIScreen mainScreen].scale;</div><div class="line">    if(scale &gt;= 3) scale = 2;</div><div class="line">    </div><div class="line">    UIImage *image = [self thumbnailForMaxWidth:1024/scale maxHeight:1024/scale];</div><div class="line">    </div><div class="line">    CGSize newSize = CGSizeMake(image.size.width*image.scale/scale, image.size.height*image.scale/scale);</div><div class="line">    </div><div class="line">    UIView *waterMarkView = [self p_markWaterMarkView:waterMarkType date:date user:user</div><div class="line">                                            placLocation:locationModel  withPhone:phone newSize:newSize xmType:xmType];</div><div class="line">    //将水印样式中的控件绘制到图片</div><div class="line">    UIGraphicsBeginImageContextWithOptions(newSize, YES, 0.0);</div><div class="line">    </div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGContextSaveGState(context);</div><div class="line">    </div><div class="line">    [image drawInRect:CGRectMake(0.0, 0.0, newSize.width, newSize.height)];</div><div class="line">    </div><div class="line">    for (UIView *view in waterMarkView.subviews) &#123;</div><div class="line">        if([view isKindOfClass:[UIImageView class]])&#123;</div><div class="line">            UIImageView *iv = (UIImageView *)view;</div><div class="line">            [iv.image drawInRect:CGRectMake(iv.left,iv.top, iv.width, iv.height)];</div><div class="line">        &#125;else if ([view isKindOfClass:[UILabel class]])&#123;</div><div class="line">            UILabel *lb = (UILabel *)view;</div><div class="line">            UIImage *lbImage = [lb imageByRenderingView];</div><div class="line">            [lbImage drawInRect:CGRectMake(lb.left, lb.top, lb.width, lb.height)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGContextRestoreGState(context);</div><div class="line">    </div><div class="line">    defaultImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    </div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">    return defaultImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-469450e831aebc08.gif?imageMogr2/auto-orient/strip" alt="自定义水印相机.gif"></p>
<p>自定义相机<a href="https://github.com/ZT0526/ZTImagePicker" target="_blank" rel="external">demo</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/22/secoendArticle/" title="从OC到Swift3.0" itemprop="url">从OC到Swift3.0</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ZT0526" target="_blank" itemprop="author">ZT0526</a>
		
  <p class="article-time">
    <time datetime="2017-08-22T03:47:40.000Z" itemprop="datePublished"> Published 2017-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>#基础部分</p>
<p>##值的声明<br>在Swift中对值的声明使用的是var、let. 使用var声明的值，是一个变量，值是可以被修改的，let声明的值，是一个常量,值一旦被指定就不可以被修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let maximumNumberOfLoginAttempts = 10</div><div class="line">var currentLoginAttempt = 0</div></pre></td></tr></table></figure>
<p>在Swift中可以自动去推断数据的类型 无需指定，上面的两个数据类型都是一个整数。这一点在OC中是没有的</p>
<p>##类型标注<br>声明数据的时候为了指定数据的类型，可以在变量名或常量名的后面加上“： ”(冒号和一个空格)然后在跟上类型名。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let nameExplicit: String = &quot;Whoopie Cushion&quot;</div></pre></td></tr></table></figure>
<p>##常量和变量的名字<br>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。可以用包括unicode以及其他的字符来作为变量名。<br>//变量名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let π = 3.14159</div><div class="line">let 你好 = &quot;你好啊&quot;</div><div class="line">let 🐶🐮 = &quot;dogcow&quot;</div></pre></td></tr></table></figure>
<p>##布尔值<br>在Swift中的bool值是true和false，而不是OC中的YES和NO<br>let onSaleInferred = true<br>let onSaleExplicit: Bool = false</p>
<p>##打印输出<br>在Swift中的打印输出使用的是print，也可以兼容使用NSlog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">print(10)</div><div class="line">print(&quot;this is \(10)&quot;) //将值转化为字符串，需要将值写在括号中并在前面加上斜杠”\”</div><div class="line"></div><div class="line">//格式化打印</div><div class="line">print(String.init(format: &quot;%@ %@ %.2f&quot;, &quot;asd&quot;,&quot;dd&quot;,10.123))</div><div class="line">print(&quot;this is \(String.init(format: &quot;%@ %@ %.2f&quot;, &quot;asd&quot;,&quot;dd&quot;,10.123))&quot;)</div><div class="line">也可以使用</div><div class="line">NSLog(&quot;this is %@ %.f&quot;, &quot;asd&quot;,&quot;1.12&quot;)</div></pre></td></tr></table></figure></p>
<p>##基本运算符<br>除了OC中已有的运算符:赋值运算符、比较运算符、逻辑运算符、组合赋值运算符、三目运算符之外，在Swift中还多了一些运算符：</p>
<p>##空合运算符（Nil Coalescing Operator）<br>空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值 b。表达式 a 必须是 可选类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let defaultColorName = &quot;red&quot;</div><div class="line">var userDefinedColorName: String?   //默认值为 nil</div><div class="line">var colorNameToUse = userDefinedColorName ?? defaultColorName</div></pre></td></tr></table></figure>
<p>##区间运算符<br>闭区间运算符”a…b”定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in 1...5 &#123;</div><div class="line">    print(&quot;\(i)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##半开区间运算符<br>半开区间运算符（a..<b）定义一个从 a="" 到="" b="" 但不包括="" 的区间。="" 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in 5..&lt;10&#123;</div><div class="line">    print(&quot;\(i)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></b）定义一个从></p>
<p>区间运算符和半开区间运算符主要用在for-in循环中<br>数据类型<br>Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array ，Set 和 Dictionary 。在使用的时候必须指定集合中的数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Array</div><div class="line">var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]</div><div class="line">//Dictionary</div><div class="line">var dic = Dictionary&lt;NSObject,AnyObject&gt;()</div><div class="line">//Set</div><div class="line">var letters = Set&lt;Character&gt;()</div></pre></td></tr></table></figure></p>
<p>##可变性<br>swift<br>如果创建一个Array、String、Set或Dictionary并且把它分配成一个变量，这个是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变其中的数据项。如果我们把Array、String、Set或Dictionary分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。</p>
<p>OC<br>字符串、数组、字典、集合都有专门的不可变的类NSArray; NSDictionary; NSSet; NSString;以及可变类 NSMutableArray;NSMutableDictionary; NSMutableSet; NSMutableString; </p>
<p>可以看到swift更加简化了数据的类型,不会专门的去设置可变类和不可变类。(目前为了兼容性，在Swift的代码中还是可以使用NSArray、NSMutableArray等类)</p>
<p>##字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Swift中字符串初始化</div><div class="line">var emptyString = &quot;&quot;               // 空字符串字面量</div><div class="line">var anotherEmptyString = String()  // 初始化方法</div><div class="line">其它的初始化方法…</div><div class="line"></div><div class="line">//判断是否为空</div><div class="line">if emptyString.isEmpty &#123;</div><div class="line">    print(&quot;Nothing to see here&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">字符串拼接的拼接可以使用”+”来完成</div><div class="line">let string1 = &quot;hello&quot;</div><div class="line">let string2 = &quot; there&quot;</div><div class="line">var welcome = string1 + string2</div></pre></td></tr></table></figure></p>
<p>##数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//创建数组</div><div class="line">var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]</div><div class="line">shoppingList[0...1] = [&quot;Bananas&quot;, &quot;Apples&quot;]</div><div class="line"></div><div class="line">//判断数组是否为空</div><div class="line">if shoppingList.isEmpty&#123;</div><div class="line">    print(&quot;kong&quot;)</div><div class="line">&#125;else&#123;</div><div class="line">    print(&quot;feikong&quot;)</div><div class="line">&#125;</div><div class="line">//添加数据</div><div class="line">shoppingList += [&quot;haha&quot;]//添加数据</div><div class="line">//遍历</div><div class="line">for item in shoppingList&#123;</div><div class="line">    print(item)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (index, value) in shoppingList.enumerated() &#123;</div><div class="line">    print(&quot;Item \(String(index + 1)): \(value)&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">包含任意类型的数组</div><div class="line">var array2: [Any] = [Any]()</div><div class="line">array2.append(1)</div><div class="line">array2.append(2.0)</div><div class="line">array2.append([3,4])</div><div class="line">array2.append(&quot;asdasd&quot;)</div><div class="line">array2.append([&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;])</div><div class="line">array2.append(sunClass2)</div><div class="line"></div><div class="line">for iterm in array2&#123;</div><div class="line">    print(&quot;this is \(iterm)&quot;)</div><div class="line">&#125;</div><div class="line">Any:可以表示任何类型，包括函数类型</div><div class="line">AnyObject:可以表示任何类类型的实例</div></pre></td></tr></table></figure>
<p>##字典<br>字典不再是像OC中那样用大括号括起来字典不再是像OC中用大括号括起来{“key1”:”value1”,”key2”:”value2”},而是使用中括号 [“key1”:”value1”,”key2”:”value2”]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">字典的创建</div><div class="line">var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</div><div class="line"></div><div class="line">//字典中某个value的访问</div><div class="line">airports[&quot;DUB&quot;]</div><div class="line"></div><div class="line">//增加</div><div class="line">airports[&quot;asd&quot;] = &quot;asd&quot;</div><div class="line">//更新</div><div class="line">airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;)</div><div class="line">//删除</div><div class="line">airports.removeValue(forKey: &quot;DUB&quot;)</div></pre></td></tr></table></figure>
<p></p>
<p>##类型转换</p>
<p>###as? as!<br>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，用类型转换操作符（as? 或 as!）。</p>
<p>条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型并强制解包。<br>当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。<br>只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<p>###as<br>向上类型转换，从一个派生类转换为基类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var num1 = 1 as Double//num1是一个值为1的浮点数变量</div><div class="line">var num2 = 2 as Int//num2是一个值为2的整型变量</div><div class="line"></div><div class="line"></div><div class="line">class father&#123;</div><div class="line">    let f = 1</div><div class="line">&#125;</div><div class="line">class sun: father&#123;</div><div class="line">    let s = 2</div><div class="line">&#125;</div><div class="line">var sunClass = sun()</div><div class="line">sunClass is sun</div><div class="line"></div><div class="line">var sunClass2 = sunClass as father</div><div class="line">print(&quot;this is \(sunClass2.s)&quot;) //报错</div><div class="line">print(&quot;this is \(sunClass2.f)&quot;) //不会报错,打印2</div></pre></td></tr></table></figure></p>
<h1 id="可选类型以及隐式可选类型"><a href="#可选类型以及隐式可选类型" class="headerlink" title="可选类型以及隐式可选类型"></a>可选类型以及隐式可选类型</h1><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>在Swift中使用可选类型来处理值有可能缺失的情况,这是C语音和OC都没有的，但这有点像Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”</p>
<p>被声明为可选类型的变量或者常量只可能有两种值:一、有值，等于xxx 二、没有值，即Swift中的nil</p>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil,如果给它们赋值失败，它们的值还是nil：<br>var surveyAnswer: String?<br>// surveyAnswer 被自动设置为 nil</p>
<p>如果给可选常量或变量赋值成功,它们的值不是nil了<br>surveyAnswer  = “haha”</p>
<h2 id="强制解析"><a href="#强制解析" class="headerlink" title="强制解析"></a>强制解析</h2><p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let assumedString: String? = &quot;An implicitly unwrapped optional string.&quot;</div><div class="line">let str1 = assumedString!</div></pre></td></tr></table></figure>
<p>如果上面的这个可选类型常量没有值 那么就会报错</p>
<h3 id="隐式可选类型"><a href="#隐式可选类型" class="headerlink" title="隐式可选类型"></a>隐式可选类型</h3><p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。这种情况下就不用去每次解析和判断可选类型了,因此Swift还提供了隐式可选类型来处理一个可选类型第一次被复制后就总会有值得情况。</p>
<p>在获取隐式可选类型的值的时候，不需要再后面加上”!”来强制解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let fullName: String! = &quot;John Appleseed&quot;</div><div class="line">let str2 = fullName</div></pre></td></tr></table></figure></p>
<p>下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let possibleString: String? = &quot;An optional string.&quot;</div><div class="line">let forcedString: String = possibleString! // 需要感叹号来获取值</div><div class="line"></div><div class="line">let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;</div><div class="line">let implicitString: String = assumedString  // 不需要感叹号</div></pre></td></tr></table></figure></p>
<p>注意:在使用可选类型或隐式可选类型的常量或变量之前都要将它们初始化，不然会报错</p>
<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>在Swift中if语句后的判断条件无需用括号括起来<br>for-in循环<br>在Swift中的for循环是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for index in 0...3 &#123;</div><div class="line">    print(&quot;index is \(index)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//index的值不需要声明, 只需要将它包含在循环的声明中，就可以对其进行隐式声明。如果不需要它的值,还可以将其用”_”来代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let base = 3</div><div class="line">let power = 10</div><div class="line">var answer = 1</div><div class="line">for _ in 1...power &#123;</div><div class="line">    answer *= base</div><div class="line">&#125;</div><div class="line"></div><div class="line">而不是OC、C中的</div><div class="line">for(int i = 0 ; i &lt; 5; i++)&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##While循环<br>while循环从计算一个条件开始。如果条件为true，会重复运行一段语句，直到条件变为false。<br>下面是 while 循环的一般格式：<br>while condition {<br>    statements<br>}<br>Repeat-While<br>while循环的另外一种形式是repeat-while，它和while的区别是在判断循环条件之前，先执行一次循环的代码块。然后重复循环直到条件为false。</p>
<p>Swift语言的repeat-while循环和其他语言中的do-while循环是类似的。<br>下面是 repeat-while循环的一般格式：<br>repeat {<br>    statements<br>} while condition
</p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>与 C 和 Objective-C 中的switch语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止switch语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用break语句。这使得switch语句更安全、更易用，也避免了因忘记写break语句而产生的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let anotherCharacter: Character = &quot;a&quot;</div><div class="line">switch anotherCharacter &#123;</div><div class="line">case &quot;a&quot;: </div><div class="line">	 print(&quot;The letter a&quot;)</div><div class="line">case &quot;A&quot;:</div><div class="line">    print(&quot;The letter A&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;Not the letter A&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在OC中,Swtich只支持int类型,char类型作为匹配。而在Swift中作为匹配的类型更加丰富多样，不仅仅支持 int类型和char类型，还可以是浮点型、字符串、区间、元组、枚举值等。在Swift中Switch可以匹配的类型很多，这样就可以将一些繁杂的if判断语句简化</p>
<p>###匹配字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let carName = &quot;asd&quot;</div><div class="line">switch carName&#123;</div><div class="line">case &quot;Six&quot;,&quot;asd&quot;:</div><div class="line">    print(&quot;this is Six&quot;)</div><div class="line">case &quot;Seven&quot;:</div><div class="line">    print(&quot;this is Seven&quot;)</div><div class="line">case &quot;Eight&quot;:</div><div class="line">    print(&quot;this is Eight&quot;)</div><div class="line">case &quot;Night&quot;:</div><div class="line">    print(&quot;this is Night&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;nothing&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//打印this is Six</p>
<p>//匹配浮点数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let value = 5.0;</div><div class="line">switch value &#123;</div><div class="line">case 1.0:</div><div class="line">    print(&quot;this is 1.0&quot;)</div><div class="line">case 2.0:</div><div class="line">    print(&quot;this is 2.0&quot;)</div><div class="line">case 5.0:</div><div class="line">    print(&quot;this is 5.0&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;others&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//打印this is 5.0</p>
<h3 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h3><p>case 分支的模式也可以是一个值的区间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let approximateCount = 62</div><div class="line">let countedThings = &quot;moons orbiting Saturn&quot;</div><div class="line">var naturalCount: String</div><div class="line">switch approximateCount &#123;</div><div class="line">case 0:</div><div class="line">    naturalCount = &quot;no&quot;</div><div class="line">case 1..&lt;5:</div><div class="line">    naturalCount = &quot;a few&quot;</div><div class="line">case 5..&lt;12:</div><div class="line">    naturalCount = &quot;several&quot;</div><div class="line">case 12..&lt;100:</div><div class="line">    naturalCount = &quot;dozens of&quot;</div><div class="line">case 100..&lt;1000:</div><div class="line">    naturalCount = &quot;hundreds of&quot;</div><div class="line">default:</div><div class="line">    naturalCount = &quot;many&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复合匹配"><a href="#复合匹配" class="headerlink" title="复合匹配"></a>复合匹配</h3><p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。当case后面的任意一种模式匹配的时候，这条分支就会被匹配。并且，如果匹配列表过长，还可以分行书写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let someCharacter: Character = &quot;e&quot;</div><div class="line">switch someCharacter &#123;</div><div class="line">case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:</div><div class="line">    print(&quot;\(someCharacter) is a vowel&quot;)</div><div class="line">case &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,</div><div class="line">     &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;:</div><div class="line">    print(&quot;\(someCharacter) is a consonant&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;\(someCharacter) is not a vowel or a consonant&quot;)</div><div class="line">&#125;</div><div class="line">// 输出 &quot;e is a vowel&quot;</div></pre></td></tr></table></figure>
<h3 id="使用-Switch-语句匹配枚举值"><a href="#使用-Switch-语句匹配枚举值" class="headerlink" title="使用 Switch 语句匹配枚举值"></a>使用 Switch 语句匹配枚举值</h3><p>你可以使用switch语句匹配单个枚举值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">directionToHead = .south</div><div class="line">switch directionToHead &#123;</div><div class="line">    case .north:</div><div class="line">        print(&quot;Lots of planets have a north&quot;)</div><div class="line">    case .south:</div><div class="line">        print(&quot;Watch out for penguins&quot;)</div><div class="line">    case .east:</div><div class="line">        print(&quot;Where the sun rises&quot;)</div><div class="line">    case .west:</div><div class="line">        print(&quot;Where the skies are blue&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>对于在OC中,方法有两种类型,类方法与实例方法。方法的组成由方法名,参数,返回值组成。<br>在Swift中函数的定义基本与OC一样。<br>主要区别为：<br>1    通过func关键词定义函数<br>2    返回值在-&gt;关键词后标注<br>各举一个类方法与实例方法例子。</p>
<ul>
<li>(UIColor*)blackColor</li>
</ul>
<ul>
<li>(void)addSubview:(UIView *)view<br>对应的swift版本<br>class func blackColor() -&gt; UIColor //类方法, 通过 class func或者static func 关键词声明，class func声明的方法可以被子类重写<br>func addSubview(view: UIView) //实例方法</li>
</ul>
<h2 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h2><p>如果你不希望为某个参数添加一个标签，可以使用一个下划线(<em>)来代替一个明确的参数标签。<br>func someFunction(</em> firstParameterName: Int, secondParameterName: Int) {<br>     // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值<br>}<br>someFunction(1, secondParameterName: 2)<br>如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</p>
<h2 id="函数中参数的修改"><a href="#函数中参数的修改" class="headerlink" title="函数中参数的修改"></a>函数中参数的修改</h2><p>oc中参数在函数体内是可以修改其值的，因为其作用类似于局部变量。但是在swift中，参数默认都是常量参数，不能在函数体内修改参数值。如果需要在函数体内修改参数值，则需要定义变量参数，即在参数名前加var关键字即可。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）比较相似。</p>
<h2 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h2><p>闭包表达式语法有如下的一般形式：<br>{ (parameters) -&gt; returnType in<br>    statements<br>}</p>
<p>在OC中我们更多的会使用block来进行完成复杂的操作，比如异步网络请求得到Json数据后，需要将Json转化为数据模型的对象、又或者是跨视图层级来完成数据处理、视图动画的执行等等。在Swift中闭包能够实现block所能实现的功能。</p>
<h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123;</div><div class="line">    // 函数体部分</div><div class="line">&#125;</div><div class="line"></div><div class="line">//不使用尾随闭包进行函数调用</div><div class="line">someFunctionThatTakesAClosure(closure: &#123;</div><div class="line">    // 闭包主体部分</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//使用尾随闭包进行函数调用</div><div class="line">someFunctionThatTakesAClosure() &#123;</div><div class="line">    // 闭包主体部分</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。<br>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 异步操作完成的处理。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var x:String?</div><div class="line">var completionHandlers:() -&gt; Void</div><div class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping (String) -&gt; Void) &#123;</div><div class="line">    //异步操作</div><div class="line">    print(&quot;这里可以执行异步操作&quot;)</div><div class="line">    </div><div class="line">    //返回时调用</div><div class="line">    completionHandler(&quot;123456&quot;)</div><div class="line">&#125;</div><div class="line">someFunctionWithEscapingClosure(completionHandler: &#123;(str: String) -&gt; Void</div><div class="line">in</div><div class="line">    x = str</div><div class="line">&#125;)</div><div class="line">print(x)</div></pre></td></tr></table></figure>
<p>#指针<br>在Swift这门语言中，会尽量去避免你去直接使用指针。但是还是会提供各种与c语言相对应的指针以供开发者在需要的是时候使用。具体的可以看<a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html</a></p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>语法:<br>在Objective-C中我们这么声明Protocol:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@protocol SampleProtocol</div><div class="line">- (void)someMethod;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>而在Swift中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">protocol SampleProtocol </div><div class="line">&#123;</div><div class="line">    func someMethod()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Swift遵循协议:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class AnotherClass: SomeSuperClass, SampleProtocol</div><div class="line">&#123;</div><div class="line">    func someMethod() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么之前Objective-C的protocol中,我们可以标志optional。在Swift中没有optional这样的标志。</p>
<p>在Swift中protocol很强大，class、enum、struct、extention都可以遵守协议</p>
<p>让枚举遵守一个协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">enum testEnum:MyProtocol &#123;</div><div class="line">    internal func test() &#123;</div><div class="line">        print(&quot;this is enum&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    case one</div><div class="line">    case two</div><div class="line">&#125;</div><div class="line"></div><div class="line">let testEnum1 = testEnum.one</div><div class="line">testEnum1.test()</div><div class="line">//输出this is enum</div></pre></td></tr></table></figure></p>
<p>结构体遵守一个协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct testStruct:MyProtocol&#123;</div><div class="line">    func test() &#123;</div><div class="line">        print(&quot;this is struct&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let testStruct1 = testStruct()</div><div class="line">testStruct1.test()</div><div class="line">//输出this is struct</div></pre></td></tr></table></figure></p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>在OC中定义一个类是这样的，需要在创建.h .m文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface class name : superclass</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation class</div><div class="line"></div><div class="line">methods</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在Swift中定义一个类,只需要一个.swift文件，变量、方法的声明 以及实现都在同一个类中完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class SomeClass &#123;</div><div class="line">// </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>OC中的属性声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (strong,nonatomic) NSString *string;</div></pre></td></tr></table></figure>
<p>Swift中的属性声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Shape &#123;</div><div class="line">    var string = &quot; string &quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OC中的getter setter方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString *)string&#123;</div><div class="line">    return @&quot;str&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setString:(NSString *)string&#123;</div><div class="line">    _string = string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift中的setter getter方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var string:String&#123;</div><div class="line">        set&#123;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        get&#123;</div><div class="line">          return &quot;string&quot;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。</p>
<p>Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为属性值的后端存储。<br>Swift 编程语言中把这些理论统一用属性来实现。</p>
<p>Swift中的只读属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var redOnly:String&#123;</div><div class="line">get&#123;</div><div class="line">    return &quot;asd&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;//get 和括号都可以去掉</div></pre></td></tr></table></figure>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>存储属性就是存储在特定类或结构体实例里的一个常量或变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct storeProperty&#123;</div><div class="line">    var value1:Int//存储属性</div><div class="line">    let value2:Int//存储属性</div><div class="line">&#125;</div><div class="line"></div><div class="line">var store = storeProperty(value1: 10,value2: 11)</div><div class="line">print(&quot;vale1:\(store.value1) value2:\(store.value2)&quot;)</div></pre></td></tr></table></figure>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。<br>//计算属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">struct caculateProperty&#123;</div><div class="line">    var value1:Int = 2</div><div class="line">    </div><div class="line">    var caculate:Int&#123;</div><div class="line">        set&#123;</div><div class="line">            value1 = newValue + 1</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        get&#123;</div><div class="line">           return value1*2</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var test = caculateProperty.init(value1: 2)</div><div class="line">print(&quot;value1: \(test.value1)&quot;)</div><div class="line"></div><div class="line">test.caculate = 2</div><div class="line">print(&quot;value1: \(test.value1)&quot;)</div><div class="line"></div><div class="line">var value2 = test.caculate</div><div class="line">print(&quot;value1: \(value2)&quot;)</div></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>Swift的扩展和 不同于Objective-C 中的扩展 ,但和Objective-C 中的分类类似。与Objective-C 不同的是，Swift 的扩展没有名字。</p>
<h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>使用关键字 extension 来声明扩展：<br>extension SomeType {<br>    // 为 SomeType 添加的新功能写到这里<br>}<br>可以通过扩展来扩展一个已有类型，使其实现一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：<br>extension SomeType: SomeProtocol, AnotherProctocol {<br>    // 协议实现写到这里<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extension ZTTestKvoAndProtocolViewController:UITextViewDelegate&#123;</div><div class="line">    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool &#123;</div><div class="line">        textStr = text</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift中的扩展很强大,具体的可以参考Extentions</p>
<p>注意<br>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>在OC和Swift中NSthread的方法基本一样</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//let queue1 = DispatchQueue(label:&quot;queue1&quot;)//默认创建串行队列</div><div class="line">        let queue1 = DispatchQueue(label:&quot;queue1&quot;,attributes:.concurrent)//创建并发队列</div><div class="line">        for i in 0...10&#123;</div><div class="line">            queue1.async &#123;</div><div class="line">                print(&quot;this is async1 \(i)&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>在OC中dispatch_once会被开发者用来实现一个单例，应为它只会执行一次，安全、简洁</p>
<p>但在Swift3.0中dispatch_once已经被废除。</p>
<h2 id="NSOperation-amp-NSOperationQueue"><a href="#NSOperation-amp-NSOperationQueue" class="headerlink" title="NSOperation &amp; NSOperationQueue"></a>NSOperation &amp; NSOperationQueue</h2><p>在OC中可以使用NSInvocationOperation将方法封装后提交到队列，也可以使用NSBlockOperation将代码块封装后提交到队列来完成任务的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">    </div><div class="line">        NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line">    </div><div class="line">    </div><div class="line">        NSBlockOperation *bloperation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">            for(int i = 0;i&lt; 20;i++)&#123;</div><div class="line">                NSLog(@&quot;子线程6：%d\n&quot;,i);</div><div class="line">    </div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">[queue addOperation:bloperation];</div><div class="line">[queue addOperation:operation];</div></pre></td></tr></table></figure>
<p>在Swift中已经废除了使用NSInvocationOperation，不再将方法封装后提交到队列，保留了NSBlockOperation(在swift3中对应的类是BlockOperation)将代码块封装后提交到队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let queue = OperationQueue.init()</div><div class="line">        let operation1 = BlockOperation.init &#123; </div><div class="line">            for i in 0...20&#123;</div><div class="line">                print(&quot;this is operation1 \(i)&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"> queue.addOperation(operation1)</div></pre></td></tr></table></figure>
<h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>OC中创建单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (CCTVUserManager *)shareObject</div><div class="line">&#123;</div><div class="line">    static CCTVUserManager *__manager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        __manager = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    return __manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift中创建单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ZTRequest&#123;</div><div class="line">    static let sharedInstance = ZTRequest()</div><div class="line">private init()&#123;&#125;//防止其它地方调用初始化方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dynamic var textStr:String!//需要在监听的值得前面加上dynamic  </div><div class="line">private var myContext = 0</div><div class="line"></div><div class="line">self.addObserver(self, forKeyPath: &quot;textStr&quot;, options: NSKeyValueObservingOptions.new, context: &amp;myContext)</div><div class="line"></div><div class="line">//MARK:响应键值监听</div><div class="line">override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123;</div><div class="line">        if &amp;myContext == context &#123;</div><div class="line">            let newValue = change?[.newKey]</div><div class="line">            print(&quot;this is kvo test newValue : \(newValue)&quot;)</div><div class="line">        &#125;else&#123;</div><div class="line">            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>//注册通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NotificationCenter.default.addObserver(self, selector: #selector(reciveNotificaTion(noti:)), name: NSNotification.Name(rawValue: &quot;testNotification&quot;), object: nil)</div><div class="line"></div><div class="line">//接收通知</div><div class="line">    @objc private func reciveNotificaTion(noti:NSNotification)&#123;</div><div class="line">        print(&quot;notifiacation : \(noti.userInfo)&quot;)</div><div class="line">&#125;</div><div class="line">//MARK:析构函数，进行解除观察,通知等操作</div><div class="line">    deinit &#123;</div><div class="line">        self.removeObserver(self, forKeyPath: &quot;textStr&quot;)</div><div class="line">        NotificationCenter.default.removeObserver(self)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>和OC中一样，Swift中代理和协议都是紧密相连的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@objc</div><div class="line">protocol MyProtocol3&#123;</div><div class="line">    func test()</div><div class="line">    @objc optional func test3()</div><div class="line">&#125;</div><div class="line"></div><div class="line">class runClass&#123;</div><div class="line">    var delegate:MyProtocol3?</div><div class="line">    </div><div class="line">    func run() -&gt; Void &#123;</div><div class="line">        delegate?.test()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class testProtocol:MyProtocol3&#123;</div><div class="line">    </div><div class="line">    //MARK:Delegate</div><div class="line">    func test() &#123;</div><div class="line">        print(&quot;this is delegate&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var testClass = runClass()</div><div class="line">testClass.delegate = testProtocol()</div><div class="line">testClass.delegate?.test()</div><div class="line">testClass.delegate?.test3?()</div></pre></td></tr></table></figure>
<p>在OC中我们检测某个类是否实现了协议方法是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([_delegate respondsToSelector:@selector(numberOfImagesInAdView:)]) &#123;</div><div class="line">        _imageCount = [_delegate numberOfImagesInAdView:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Swift3.0中，检测某个类是否实现了协议方法是这样的<br>delegate?.test3?()</p>
<h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="external">The Swift Programming Language (Swift 3.0.1)</a></p>
<p><a href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/" target="_blank" rel="external">Start Developing iOS Apps (Swift)</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 3.0.1)</a></p>
<p>推荐学习的开源项目<br><a href="https://github.com/mozilla-mobile/firefox-ios" target="_blank" rel="external">firefox-ios</a><br>编译时的环境:cocoapods 1.1.1    Homebrew 1.1.1    xcode8.0</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/22/thirdArticle/" title="理解和分析应用程序崩溃报告" itemprop="url">理解和分析应用程序崩溃报告</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ZT0526" target="_blank" itemprop="author">ZT0526</a>
		
  <p class="article-time">
    <time datetime="2017-08-22T03:38:51.000Z" itemprop="datePublished"> Published 2017-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>写在前面：本文会在最开头将苹果官方的文档<a href="https://developer.apple.com/library/prerelease/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-ANALYZING_CRASH_REPORTS" target="_blank" rel="external">Understanding and Analyzing Application Crash Reports</a>进行翻译,但这不仅仅是一篇翻译的文章，本文会让大家更加全面的了解ios的崩溃报告的获取、分析、用途。翻译的时候我会结合自己以往的使用经验来进行翻译。</p>
<p>理解和分析应用程序崩溃报告</p>
<p>重要提示：本文档包含有关开发中的一个接口或技术的初步信息。此信息将被更改，并根据本文档实现的软件应该用最终的操作系统软件进行测试。</p>
<p>当应用程序崩溃时，创建了一个崩溃报告，这是非常有用的了解什么造成的崩溃。本文件包含重要的信息，如何symbolicate，理解和解释的崩溃报告。</p>
<p>###简介</p>
<p>当应用程序崩溃时，将创建一个崩溃报告并存储在设备上。崩溃报告描述的情况下，应用程序终止，在大多数情况下，包括每个执行线程的一个完整的回溯，通常对于调试应用中的问题是非常有用。你应该看看这些崩溃报告，了解你的应用程序有什么崩溃，然后尝试修复它们。</p>
<p>有回溯的崩溃报告需要被符号化了才可以分析。符号化(symbolication)成人们可读的函数名称和行号来取代内存地址。如果你通过Xcode的设备窗口来获取设备的崩溃日志，它们将在几秒钟后自动被符号化。否则，你将需要自己将崩溃日志符号化，通过自己导入崩溃文件到Xcode设备窗口。看到符号化（symbolicating）后的崩溃报告。</p>
<p>低内存报告不同于其他的崩溃报告，没有回朔在这种类型的报告。当低内存崩溃发生时，你必须调查你的内存使用模式和对低内存警告的响应。此文档指向了您可能会发现有用的多个内存管理引用。</p>
<p>###获取崩溃和低内存报告</p>
<p><a href="https://developer.apple.com/library/content/qa/qa1747/_index.html" target="_blank" rel="external">调试部署iOS应用程序</a>  讨论如何直接从iOS设备获取崩溃和内存不足的报道。</p>
<p>在<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html" target="_blank" rel="external">应用程序分发指南</a>中的<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AnalyzingCrashReports/AnalyzingCrashReports.html" target="_blank" rel="external">分析崩溃报告</a> 讨论如何从TestFlight beta测试者和那些已经从App Store下载应用程序的用户中收集崩溃报告。</p>
<p>###symbolicating崩溃报告</p>
<p>symbolication是解决回溯地址的源代码的方法或函数名的过程，称为符号化。没有经过符号化的崩溃报告，是不能了解具体的崩溃信息的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注：低内存报告不需要symbolicated。</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">注：来自MacOS崩溃报告通常是已经符号化的，或部分符号化后的(symbolicated)。</div><div class="line">本节重点symbolicating从iOS，WatchOS，和TVOS的崩溃报告，但整体过程类似MacOS。</div></pre></td></tr></table></figure>
<pre><code>图1概述了崩溃报告和symbolication过程。
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1716542-41671bb546c2be61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取崩溃报告以及符号化过程"></p>
<p>1.当编译器将源代码翻译成机器代码时，它也会生成调试符号，它将编译后的二进制中的每一个机器指令映射到源代码的行源代码中。根据调试信息格式（debug_information_format）编译设置，这些调试符号存储在二进制或在同伴的调试符号文件（dsym）。默认情况下，调试版本的应用程序的调试符号存储在编译后的二进制中，而发布版本的应用程序的调试符号存储在相应的dsym文中件以减少二进制大小。<br>调试符号文件和应用程序二进制文件与每一个build生成的UUID捆绑在一起。一个新的UUID生成是由build一个应用产生的，它应用程序每次build(编译打包)的唯一标识。即使一个功能相同的可执行文件是从相同的源代码重构，具有相同的编译器设置，也会有不同的生成的UUID。调试符号文件的后续版本，甚至来自同一个源文件，不会与其他版本的二进制文件相混淆。</p>
<p>2.当你的归档(archive)要分发的应用程序，Xcode会收集应用程序二进制随着.dsym文件，并且存放在home文件夹里。你可以在Xcode的组织者在“归档”部分，找到所有你归档后(archived)的应用。有关创建存档的更多信息，可以参考<a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html" target="_blank" rel="external">应用程序分发指南</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">重要：为了符号化(symbolicate)从测试人员，审查程序，和客户得到的崩溃报告，你必须保留每个存档您的应用程序。</div></pre></td></tr></table></figure></p>
<p>3.如果你是通过App Store发布的应用程序，或使test flight进行测试，你将选择包括dsym文件到iTunes Connect。在提交对话框中，选择“您的应用程序的应用程序符号……”。为了接收来test flight收集的 以及 那些选择了分享的诊断数据的客户的崩溃报告，上传你的dsym文件是必要的 。有关崩溃报告服务的更多信息，可以参考应用程序分发指南。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">重要：从app review收到的崩溃报告将是unsymbolicated，即使你有上传dsym文件到iTunes Connect。</div><div class="line">你需要使用Xcode 来symbolicate任何从app review得到的崩溃报告。</div><div class="line">看下午中&quot;到symbolicating崩溃报告Xcode&quot;。</div></pre></td></tr></table></figure></p>
<p>4.当你的应用程序崩溃时，一个unsymbolicated崩溃报告会被创建并存储在设备上。</p>
<p>5.用户可以按照<a href="https://developer.apple.com/library/content/qa/qa1747/_index.html" target="_blank" rel="external">调试部署iOS应用程序的步骤</a>，直接从他们的设备中检索崩溃报告。如果你的应用程序通过AdHoc or Enterprise distribution发布的，这是从你的用户获取崩溃报告的唯一途径。</p>
<p>6.从设备检索得到的未符号化的(unsymbolicated)崩溃报告需要使用Xcode来符号化(symbolicated)。Xcode使用您的应用程序的二进制在源代码中的源位置的回溯替换每个地址相关联的dsym文件。其结果是一个符号化的(symbolicated)崩溃报告。</p>
<p>7.如果用户选择了与苹果共享诊断数据，或者如果用户通过TestFlight安装了你的应用程序，崩溃报告会被上传到应用商店。</p>
<p>8.App Store 符号化崩溃报告  并且将类似的崩溃报告分组。类似的崩溃报告的集合被称为崩溃点。</p>
<p>9.符号化的崩溃报告是在Xcode’s Crashes organizer提供给你的。</p>
<p>###Bitcode<br>Bitcode是一个编译程序的中间表示。当你可以用bitcode来 archive an application，编译器产生的二进制文件包含bitcode而不是机器代码。一旦二进制已经上传到App Store，这可以被编译成机器码。App Store在将来，在没有任何行动的一部分的情况下，利用未来的改进的编译器，再次编译。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-da1b5ebb9f45a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Bitcode compilation process"></p>
<p>因为你的二进制最后的编译出现在App Store，Mac将不包含符号化从应用程序审查或用户发给你他们从设备中取得的崩溃报告所需要的调试符号文件(.dsym)。虽然dsym文件是您归档应用程序(archive your application)的时候产生的，它是为bitcode二进制并不能用来symbolicate崩溃报告。App Store在你从Xcode或从iTunes Connect网站，可以获得编译的bitcode并且可以下载的过程中，产生dsym文件。符号化从应用程序审查或用户发给你他们从设备中取得的崩溃报告，你必须下载这些dsym文件。崩溃报告获得通过崩溃报告服务将自动symbolicated。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">重要：二进制应用程序商店会比最初二进制编译，有不同的UUID</div></pre></td></tr></table></figure>
<p>###从Xcode获取dSYMs文件<br>1.下载dsyms文件<br>在归档管理中选择相应的归档并下载dsyms文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-b92d2c3b7e4f5e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-0@2x.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-6bc36eb3ec7282b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-1@2x.png"></p>
<p>2.在归档出的文件中找到dSYMs文件<br><img src="http://upload-images.jianshu.io/upload_images/1716542-edc067855fbf744b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-130da505d3b99940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-3@2x.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-a2650a367b7d7bcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-4@2x.png"></p>
<p>###确定崩溃报告是否被符号化</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-cc0f6a4616b017b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tn2151_symbolication_levels.png"></p>
<p>###符号化崩溃报告<br>1.符号化用xcode编译安装软件的设备上的崩溃报告<br>当应用在设备上运行，遇到崩溃的时候会产生崩溃日志。如果这个应用是用xcode直接在设备上编译运行的，那么就可以将手机连接到编译的时候所用的电脑上，打开xcode，在Window的Devices中去查看日志。找到日志的时候，xcode会自己去符号化崩溃日志。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-d8d2528505d512e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选取设备"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-12f462f74b01c477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看设备日志"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-59ef6016fa4e3d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xcode自己去符号化崩溃文件"></p>
<p>2.符号化用安装包安装在测试设备上的应用所产生的崩溃日志<br>符号化的时候需要准备symbolicatecrash文件 .dSYM文件 以及.app文件<br>符号化前先检查一下三者的uuid是不是一致的,只有是一致的才能符号化成功。<br>查看xx.app文件的uuid的方法：<br>dwarfdump –uuid xxx.app/xxx (xxx工程名)<br>查看xx.app.dSYM文件的uuid的方法令：<br>dwarfdump –uuid xxx.app.dSYM (xxx工程名)<br>而.crash的uuid位于，crash日志中的Binary Images:中的第一行尖括号内。如：armv7 <8bdeaf1a0b233ac199728c2a0ebb4165></8bdeaf1a0b233ac199728c2a0ebb4165></p>
<p>将三种文件拷贝到同一个目录中，在终端中使用命令<br>./symbolicatecrash ./<em>.crash ./</em>.app.dSYM &gt; xxx.crash来解析崩溃日志。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-6cf5ed8bbecce6fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="asdasd"></p>
<p>如果想今后解析日志的时候更方便一点，特别是解析多个崩溃日志的时候，如果一个一个去解析的话，很花费时间的。我的话，会将这些写到一个脚本中，解析的时候就只用执行脚本，就可以很方便快捷的获取到崩溃日志。</p>
<p>3.获取并符号化线上的崩溃报告<br>一.通过打包上线时的xcode来获取线上的崩溃报告<br>线上app的崩溃日志会被app store收集并符号化分组。类似的崩溃报告的集合被称为崩溃点。(如果用户选择了与苹果共享诊断数据，这些崩溃日志才会被收集并被符号化)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-a74a8ad28c33edb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-0@2x.png"></p>
<p>在点击相应应用后，会显示此应用的崩溃集合。可以看到每一个集合中都会有很多个设备，如果右键进去查看的话，会看到很多文件。<br><img src="http://upload-images.jianshu.io/upload_images/1716542-35b71f1517a3cdcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-0.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-777d4adcda3b8b91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-1.png"><br>再次右键进去查看的话，会最终看到详细的崩溃日志</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-7b62ba2a93342a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-7.png"></p>
<p>当选中了一个崩溃集合后，如果选择在项目中打开，会在项目代码中找到具体出问题的代码</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-cda9605cbcc8c920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-8.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-333d4f8d5e8a6556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-2.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-59618d5d1f41eaf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161122-3.png"><br>二、通过友盟等第三方工具来获取崩溃日志<br>崩溃日志列表<br><img src="http://upload-images.jianshu.io/upload_images/1716542-69d3702394f2ff26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161209-0.png"><br>其中的一个崩溃日志<br><img src="http://upload-images.jianshu.io/upload_images/1716542-ec82ba3e8db570b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161209-1.png"><br>崩溃的代码的位置，这个是最关键的，可以通过这个来找到代码中的出问题的地方<br><img src="http://upload-images.jianshu.io/upload_images/1716542-1c2964ec6ead1bbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161209-2.png"><br>export dSYMPath=”$(find ~/Library/Developer/Xcode -iname ‘*.dSYM’ -print0 | xargs -0 dwarfdump -u  | grep C0349572-9622-3A00-81D0-4DDE0E00DC7A | sed -E ‘s/^[^/]+//‘ | head -n 1)”;是为了找到归档时候产生的dsym文件的路径</p>
<p>dwarfdump –arch=armv7 –lookup 0x426031 “$dSYMPath”是符号化的关键，可以找出出问题的地方。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-4eea0206ed055974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161209-4.png"></p>
<p>###分析符号化后的崩溃报告<br>1.头部<br>每个崩溃报告都会以一个头部开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Listing 4  Excerpt of the header from a crash report.</div><div class="line">Incident Identifier: B6FD1E8E-B39F-430B-ADDE-FC3A45ED368C</div><div class="line">CrashReporter Key: f04e68ec62d3c66057628c9ba9839e30d55937dc</div><div class="line">Hardware Model: iPad6,8</div><div class="line">Process: TheElements [303]</div><div class="line">Path: /private/var/containers/Bundle/Application/888C1FA2-3666-4AE2-9E8E-62E2F787DEC1/TheElements.app/TheElements</div><div class="line">Identifier: com.example.apple-samplecode.TheElements</div><div class="line">Version: 1.12</div><div class="line">Code Type: ARM-64 (Native)</div><div class="line">Role: Foreground</div><div class="line">Parent Process: launchd [1]</div><div class="line">Coalition: com.example.apple-samplecode.TheElements [402]</div><div class="line"> </div><div class="line">Date/Time: 2016-08-22 10:43:07.5806 -0700</div><div class="line">Launch Time: 2016-08-22 10:43:01.0293 -0700</div><div class="line">OS Version: iPhone OS 10.0 (14A5345a)</div><div class="line">Report Version: 104</div></pre></td></tr></table></figure>
<p>以下的值是特别值得注意的:</p>
<p>Incident Identifier: 一个唯一的标识. 不会存在共用一个标识的崩溃报告.<br>CrashReporter Key:是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到100个崩溃日志的CrashReporter Key值都是相同的，或者只有少数几个不同的CrashReport值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。<br>Process: 是应用名称。中括号里面的数字是闪退时应用的进程ID。<br>Version: 崩溃进程的版本号. 这个值包含在 CFBundleVersion and CFBundleVersionString中.<br>Code Type: 崩溃日志所在设备的架构. 会是ARM-64, ARM, x86-64, or x86中的一个.<br>OS Version: 崩溃发生时的系统版本</p>
<p>###异常信息<br>异常信息会列出异常的类型、位置。</p>
<p>以下的内容是摘录的一个崩溃报告的异常代码段,该崩溃报告是一个进程由于一个未捕获的异常而崩溃产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exception Type: EXC_CRASH (SIGABRT)</div><div class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</div><div class="line">Exception Note: EXC_CORPSE_NOTIFY</div><div class="line">Triggered by Thread: 0</div></pre></td></tr></table></figure>
<p>以下的内容是摘录于一个因为空指针的访问而崩溃产生的崩溃报告的异常代码段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception Type: EXC_BAD_ACCESS (SIGSEGV)</div><div class="line">Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000</div><div class="line">Termination Signal: Segmentation fault: 11</div><div class="line">Termination Reason: Namespace SIGNAL, Code 0xb</div><div class="line">Terminating Process: exc handler [0]</div><div class="line">Triggered by Thread: 0</div></pre></td></tr></table></figure>
<p>异常信息中可能出现的字段的解释如下：<br>Exception Codes: 处理器的具体信息有关的异常编码成一个或多个64位进制数。通常情况下，这个区域不会被呈现，因为将异常代码解析成人们可以看懂的描述是在其它区域进行的。<br>Exception Subtype: 供人们可读的异常代码的名字<br>Exception Message: 从异常代码中提取的额外的可供人们阅读的信息.<br>Exception Note: 不是特定于一个异常类型的额外信息.如果这个区域包含SIMULATED (这不是一个崩溃)然后进程没有崩溃，但是被watchdog杀掉了<br>Termination Reason: 当一个进程被终止的时的原因。<br>Triggered by Thread: 异常所在的线程.</p>
<p>下面的小节将介绍一些最常见的异常类型。</p>
<p>###Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS]</p>
<p>进程试图访问无效的内存，或试图以内存的保护级别所不允许的方式去访问内存（例如，写入到只读存储器）。异常类型字段(Exception Subtype)包含一个kern_return_t描述错误，和错误的访问的内存地址。</p>
<p>这里是调试一个Bad Memory Access的一些小技巧:</p>
<p>1.如果objc_msgSend或者objc_release在回溯(Backtraces)的顶部附近，这个进程可能是尝试给一个释放的对象发送消息。你应该用Zombies instrument(调试僵尸对象的工具)来更好的理解这个崩溃。</p>
<p>2.如果gpus_ReturnNotPermittedKillClient在回溯的顶部附近，这个进程是由于在后台尝试用OpenGL ES 或者 Metal来渲染，而被杀掉的。<a href="https://developer.apple.com/library/content/qa/qa1766/_index.html" target="_blank" rel="external">See QA1766: How to fix OpenGL ES application crashes when moving to the background.</a></p>
<p>3.用地址消毒剂(<a href="https://developer.apple.com/videos/play/wwdc2015/413/" target="_blank" rel="external">Address Sanitizer</a>,这是xcode7引入的新特性 )来跑程序。<br>The address sanitizer adds additional instrumentation around memory access in your compiled code. As your application runs, Xcode will alert you if memory is accessed in a way that could lead to a crash.</p>
<p>###Abnormal Exit (异常退出)[EXC_CRASH // SIGABRT]</p>
<p>进程异常退出。该异常类型崩溃最常见的原因是未捕获的Objective-C和C++异常和调用abort()。<br>如果他们需要太多的时间来初始化，程序将被终止，因为触发了看门狗。如果是因为启动的时候被挂起，所产生的崩溃报告异常类型(Exception Subtype)将是launch_hang。</p>
<p>###Trace Trap (追踪捕获)[EXC_BREAKPOINT // SIGTRAP]<br>类似于异常退出,这个异常是为了给附加的调试器中断的过程的机会在其执行一个特定的点。您可以从您自己的代码引发此异常使用__builtin_trap()函数。如果没有调试器连接,进程将被终止并生成崩溃报告。</p>
<p>###Illegal Instruction(非法指令) [EXC_BAD_INSTRUCTION // SIGILL]<br>进程试图执行非法或未定义指令。这个进程可能试图通过一个配置错误的函数指针，跳到一个无效的地址。在英特尔处理器,ud2操作码造成EXC_BAD_INSTRUCTION异常但通常用于调试的时候的追踪。在英特尔处理器上的swift代码因为这个异常类型而被终止，如果在运行时遇到意外情况。有关详细信息,请参阅追踪捕获。</p>
<p>###Resource Limit [EXC_RESOURCE]<br>这个进程超出了资源消耗的限制。这是一个从操作系统通知,进程是使用太多的资源。这虽然不是崩溃但也会生成崩溃日志。</p>
<p>##其它的异常信息</p>
<p>0x8badf00d: 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。  通常是应用花费太多时间而无法启动、终止或响应用系统事件。</p>
<p>0xbad22222: 该编码表示 VoIP 应用因为过于频繁重启而被终止。<br>0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。<br>0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">待补充</div></pre></td></tr></table></figure>
<p>###其它捕捉和符号化崩溃日志的方法<br>1.通过代码来捕捉崩溃信息，并发送到指定的地方<br>在项目的代码中重新指定顶层的错误处理的handler,这样可以在软件崩溃前的最后一秒调用错误处理的函数来获得崩溃的信息(这里的信息已经是被符号化的)。然后将崩溃信息发送到自己的服务器或者其它的地方，以便开发者巩固自己的代码的可靠性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">    [[AFNetworkReachabilityManager sharedManager] startMonitoring];</div><div class="line">    appDelegate = self;</div><div class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    self.window.backgroundColor = [UIColor whiteColor];</div><div class="line">    UILocalNotification *notification = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</div><div class="line">    _notification = notification;</div><div class="line">    </div><div class="line">    NSSetUncaughtExceptionHandler(&amp;caughtExceptionHandler);</div><div class="line">    /*Changes the top-level error handler.</div><div class="line">    Sets the top-level error-handling function where you can perform last-minute logging before the program terminates</div><div class="line">    */</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void caughtExceptionHandler(NSException *exception)&#123;</div><div class="line">    /**</div><div class="line">     *  获取异常崩溃信息</div><div class="line">     */</div><div class="line">    NSArray *callStack = [exception callStackSymbols];</div><div class="line">    NSString *reason = [exception reason];</div><div class="line">    NSString *name = [exception name];</div><div class="line">    NSString *content = [NSString stringWithFormat:@&quot;========异常错误报告========\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;,name,reason,[callStack componentsJoinedByString:@&quot;\\n&quot;]];</div><div class="line">    </div><div class="line">    //把异常崩溃信息发送至开发者邮件</div><div class="line">    NSMutableString *mailUrl = [NSMutableString string];</div><div class="line">    [mailUrl appendString:@&quot;mailto:xxx@qq.com&quot;];</div><div class="line">    [mailUrl appendString:@&quot;?subject=程序异常崩溃信息，请配合发送异常报告，谢谢合作！&quot;];</div><div class="line">    [mailUrl appendFormat:@&quot;&amp;body=%@&quot;, content];</div><div class="line">    // 打开地址</div><div class="line">    NSString *mailPath = [mailUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:mailPath]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/21/firstArticle/" title="动画分享" itemprop="url">动画分享</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ZT0526" target="_blank" itemprop="author">ZT0526</a>
		
  <p class="article-time">
    <time datetime="2017-08-21T09:27:33.000Z" itemprop="datePublished"> Published 2017-08-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="动画分享"><a href="#动画分享" class="headerlink" title="动画分享"></a>动画分享</h1><h3 id="Core-Animation结构"><a href="#Core-Animation结构" class="headerlink" title="Core Animation结构"></a>Core Animation结构</h3><p>继承关系</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-adfb456c9829406b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="626233-43bafe84d8aee5bf.png"></p>
<p>其中灰色虚线表示继承关系，红色表示遵守协议。</p>
<p>核心动画中所有类都遵守CAMediaTiming协议。<br>CAAnaimation是个抽象类，不具备动画效果，必须用它的子类才有动画效果。</p>
<p>CAAnimationGroup是个动画组，可以同时进行缩放，旋转（同时进行多个动画）。</p>
<p>CATransition是转场动画，界面之间跳转（切换）都可以用转场动画。</p>
<p>CAPropertyAnimation也是个抽象类，本身不具备动画效果，只有子类才有。</p>
<p>CABasicAnimation和CAKeyframeAnimation：<br>CABasicAnimation基本动画，做一些简单效果。<br>CAKeyframeAnimation帧动画，做一些连续的流畅的动画。</p>
<h3 id="CAMediaTiming协议"><a href="#CAMediaTiming协议" class="headerlink" title="CAMediaTiming协议"></a>CAMediaTiming协议</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>beginTime</td>
<td>开始时间,可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，<br>CACurrentMediaTime()为图层的当前时间</td>
</tr>
<tr>
<td>duration</td>
<td>动画的持续时间,默认为0</td>
</tr>
<tr>
<td>speed</td>
<td>播放速度，默认的值为 1.0.如果你改变这个值为 2.0,动画会用 2 倍的速度播放。这样的影响就是使持续时间减半。<br>如果你指定的持续时间为 6 秒,速度为 2.0,动画就会播放 3 秒钟即一半的持续时间。</td>
</tr>
<tr>
<td>Autoreverses</td>
<td>设定这个属性为 YES 时,在它到达目的地之后,<br>动画的返回到开始的值,代替了直接跳转到开始的值，过渡平滑</td>
</tr>
<tr>
<td>repeatCount</td>
<td>重复次数，无限循环可以设置HUGE_VALF或者MAXFLOAT</td>
</tr>
<tr>
<td>repeatDuration</td>
<td>重复时间</td>
</tr>
<tr>
<td>fillMode</td>
<td>决定动画执行完后 对象的状态</td>
</tr>
</tbody>
</table>
<p>参考文章<a href="http://www.cocoachina.com/programmer/20131218/7569.html" target="_blank" rel="external">控制动画时间</a> <br><a href="http://ronnqvi.st/controlling-animation-timing/" target="_blank" rel="external">Controlling Animation Timing</a></p>
<h3 id="CAAnimation——简介"><a href="#CAAnimation——简介" class="headerlink" title="CAAnimation——简介"></a>CAAnimation——简介</h3><p>是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>removedOnCompletion</td>
<td>默认为YES，代表动画执行完毕后就从图层上移除，<br>图形会恢复到动画执行前的状态。<br>如果想让图层保持显示动画执行后的状态，<br>那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</td>
</tr>
<tr>
<td>timingFunction</td>
<td>速度控制函数，控制动画运行的节奏</td>
</tr>
<tr>
<td>delegate</td>
<td>代理,包含了动画开始和结束的回调方法</td>
</tr>
</tbody>
</table>
<p>fillMode属性的设置：</p>
<ul>
<li><p>kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态</p>
</li>
<li><p>kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态</p>
</li>
<li><p>kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。</p>
</li>
<li><p>kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</p>
</li>
</ul>
<p>速度控制函数(CAMediaTimingFunction)：</p>
<ul>
<li><p>kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</p>
</li>
<li><p>kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</p>
</li>
<li><p>kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</p>
</li>
<li><p>kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</p>
</li>
</ul>
<h3 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a>CAPropertyAnimation</h3><p>是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>keyPath</td>
<td>指定了动画的关键路径</td>
</tr>
</tbody>
</table>
<h3 id="CATransition——转场动画"><a href="#CATransition——转场动画" class="headerlink" title="CATransition——转场动画"></a>CATransition——转场动画</h3><p>CATransition是CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。</p>
<p>UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果。我们可以通过CATransition来自定义转场动画。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>动画过渡类型</td>
</tr>
<tr>
<td>subtype</td>
<td>动画过度方向</td>
</tr>
<tr>
<td>startProgress</td>
<td>动画起点(在整体动画的百分比)</td>
</tr>
<tr>
<td>endProgress</td>
<td>动画终点(在整体动画的百分比)</td>
</tr>
<tr>
<td>addAnimation: forKey:</td>
<td>把转场动画添加到layer上</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>类型字符串</th>
<th>效果说明</th>
<th>对应常量    </th>
</tr>
</thead>
<tbody>
<tr>
<td>fade</td>
<td>交叉淡化过渡</td>
<td>kCATransitionFade    </td>
</tr>
<tr>
<td>push</td>
<td>新视图把旧视图推出去</td>
<td>kCATransitionPush    </td>
</tr>
<tr>
<td>moveIn</td>
<td>新视图移到旧视图上面</td>
<td>kCATransitionReveal    </td>
</tr>
<tr>
<td>reveal</td>
<td>将旧视图移开,显示下面的新视图</td>
<td>kCATransitionMoveIn    </td>
</tr>
<tr>
<td>cube</td>
<td>立方体翻滚效果</td>
<td>私有</td>
</tr>
<tr>
<td>oglFlip</td>
<td>上下左右翻滚效果</td>
<td>私有</td>
</tr>
<tr>
<td>suckEffect</td>
<td>收缩效果,如一块布被抽走</td>
<td>私有</td>
</tr>
<tr>
<td>rippleEffect</td>
<td>水滴效果</td>
<td>私有</td>
</tr>
<tr>
<td>pageCurl</td>
<td>向上翻页效果</td>
<td>私有</td>
</tr>
<tr>
<td>pageUnCurl</td>
<td>向下翻页效果</td>
<td>私有</td>
</tr>
<tr>
<td>cameraIrisHollowOpen</td>
<td>相机镜头打开效果</td>
<td>私有        </td>
</tr>
<tr>
<td>cameraIrisHollowClose</td>
<td>相机镜头关闭效果</td>
<td>私有        </td>
</tr>
</tbody>
</table>
<h3 id="CABasicAnimation——基本动画"><a href="#CABasicAnimation——基本动画" class="headerlink" title="CABasicAnimation——基本动画"></a>CABasicAnimation——基本动画</h3><p>属性说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromValue</td>
<td>keyPath对应的属性的初始值</td>
</tr>
<tr>
<td>toValue</td>
<td>keyPath对应的属性的结束值</td>
</tr>
</tbody>
</table>
<p>动画过程说明：</p>
<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。</p>
<p>keyPath内容是CALayer的可以用来制作动画(Animatable)的属性。动画的产生是由于CABasicAnimation的这些valuse作用到了keyPath，也就是CALayer中的Animatable类型的属性上，如transform，position等。</p>
<p>如果fillMode = kCAFillModeForwards同时removedOnComletion = NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</p>
<h3 id="CAKeyframeAnimation——关键帧动画"><a href="#CAKeyframeAnimation——关键帧动画" class="headerlink" title="CAKeyframeAnimation——关键帧动画"></a>CAKeyframeAnimation——关键帧动画</h3><p>关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是：</p>
<ul>
<li>CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值</li>
<li>CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>values</td>
<td>NSArray对象。里面的元素称为“关键帧”(keyframe)。<br>动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</td>
</tr>
<tr>
<td>path</td>
<td>可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。<br>path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略</td>
</tr>
<tr>
<td>keyTimes</td>
<td>可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，<br>keyTimes中的每一个时间值都对应values中的每一帧。<br>如果没有设置keyTimes，各个关键帧的时间是平分的</td>
</tr>
</tbody>
</table>
<h3 id="CAAnimationGroup——动画组"><a href="#CAAnimationGroup——动画组" class="headerlink" title="CAAnimationGroup——动画组"></a>CAAnimationGroup——动画组</h3><p>动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。</p>
<p>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>animations</td>
<td>用来保存一组动画对象的NSArray</td>
</tr>
</tbody>
</table>
<h3 id="CASpringAnimation-弹性动画"><a href="#CASpringAnimation-弹性动画" class="headerlink" title="CASpringAnimation 弹性动画"></a>CASpringAnimation 弹性动画</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mass</td>
<td>质量，影响图层运动时的弹簧惯性，质量越大，<br>弹簧拉伸和压缩的幅度越大</td>
</tr>
<tr>
<td>stiffnes</td>
<td>刚度系数(劲度系数/弹性系数)，刚度系数越大，<br>形变产生的力就越大，运动越快</td>
</tr>
<tr>
<td>damping</td>
<td>阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快</td>
</tr>
<tr>
<td>initivelocity</td>
<td>初始速率，动画视图的初始速度大小;速率为正数时，<br>速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反</td>
</tr>
<tr>
<td>settingDuration</td>
<td>结算时间(根据动画相关参数估算弹簧开始运动到停止的时间，<br>动画设置的时间最好根据此时间来设置)</td>
</tr>
</tbody>
</table>
<p>CASpringAnimation是ios9及以上版本才可以使用，想要适配ios9以前版本的话  需要自己动手来完成弹性动画</p>
<p>阻尼震荡</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-b927346e11283948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="496px-Damped_oscillation_graph.svg.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-6e299b7a4934bdfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D103F63B-50DE-4ED6-97AA-10FD39E4B5DB.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-29a97b4355b568b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14981914785849.png"></p>
<p>参考资料<a href="http://kittenyang.com/deformationandgooey/" target="_blank" rel="external">粘性动画</a></p>
<p><a href="http://kittenyang.com/deformationandgooey/" target="_blank" rel="external">查看数学函数对应的图像的网站</a></p>
<h3 id="CAKeyframeAnimation-关键帧动画"><a href="#CAKeyframeAnimation-关键帧动画" class="headerlink" title="CAKeyframeAnimation 关键帧动画"></a>CAKeyframeAnimation 关键帧动画</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>values</td>
<td>指定关键点的值</td>
</tr>
<tr>
<td>path</td>
<td>可以设置一个CGPathRef / CGMutablePathRef，让层跟着路径移动。<br>path只对CALayer的anchorPoint和position起作用。如果你设置了path，<br>那么values将被忽略.</td>
</tr>
<tr>
<td>keyTimes</td>
<td>是走到某一个关键点花费的时间百分比(0～1)，keyTimes中的每一个<br>时间值都对应values中的每一帧(两个数组的个数必须一致)，<br>当keyTimes没有设置的时候,各个关键帧的时间是平分的。</td>
</tr>
<tr>
<td>通过 设置不同的属性值values 动画</td>
<td>关键帧动画创建第一种方式</td>
</tr>
<tr>
<td>通过 绘制路径path 动画</td>
<td>关键帧动画创建第二种方式</td>
</tr>
</tbody>
</table>
<h4 id="AnimationWithKeyPath的值"><a href="#AnimationWithKeyPath的值" class="headerlink" title="AnimationWithKeyPath的值"></a>AnimationWithKeyPath的值</h4><p>属性后面的描述中带有Animatable的都可以作为keyPath<br>如CAlayer的transform，position等等</p>
<h3 id="水波动画"><a href="#水波动画" class="headerlink" title="水波动画"></a>水波动画</h3><p>正弦型函数解析式：y=Asin（ωx+φ）+h<br>各常数值对函数图像的影响：<br>φ（初相位）：决定波形与X轴位置关系或横向移动距离（左加右减）<br>ω：决定周期（最小正周期T=2π/|ω|）<br>A：决定峰值（即纵向拉伸压缩的倍数）<br>h：表示波形在Y轴的位置关系或纵向移动距离（上加下减）</p>
<h3 id="CATransFrom3D"><a href="#CATransFrom3D" class="headerlink" title="CATransFrom3D"></a>CATransFrom3D</h3><p>iOS设备上，是按照左手系的三维空间，即正面面对设备屏幕，坐标原点从屏幕左上方起，x轴指向右方，y轴指向下方，z轴为屏幕指向眼球。而macOS上是右手系，原点是屏幕左下角，x轴指向右方，y轴指向上方（相反），z轴同样为屏幕指向眼球，要注意</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-464e079533c43c0d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5c010c6b630ab7aa0892428016d7e.jpeg"></p>
<p>3D效果中平移、旋转、缩放、都是通过矩阵的变换得到的</p>
<pre><code>CATransform3D结构体
struct CATransform3D
{
  CGFloat m11, m12, m13, m14;
  CGFloat m21, m22, m23, m24;
  CGFloat m31, m32, m33, m34;
  CGFloat m41, m42, m43, m44;
};
</code></pre><p>这个结构体对应这样一个4x4的矩阵</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-a8d66f0e42d746ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C8B0A3D9-796D-40BF-A5A8-7AB02E249230.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-8375d1ba7bb0713f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4196_131230104304_1.png"></p>
<p>这里的矩阵变换主要是两个矩阵相乘，将坐标向量乘以变换的矩阵，得到变换后的坐标。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-0e294043de100831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4196_131230104316_1.png"></p>
<p>1.平移</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-d48100586f04c975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2766C09E-7B01-48C2-B42B-77A1E56B29FB.png"></p>
<pre><code>对应API:
CATransform3D CATransform3DMakeTranslation(CGFloat tx, CGFloat ty, CGFloat tz);
</code></pre><p>2.缩放</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-385974b615a1fec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BDCEC978-9B92-4149-8530-148A80C22C6B.png"></p>
<pre><code>对应API:
CATransform3D CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
</code></pre><p>3.旋转</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1716542-816022e915e29bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="59C76777-3EEB-4887-9C0E-18E6B3163D4E.png"></p>
<p>4.为什么设置m34<br>当我们要实现近大远小的效果的时候，为什么只需要设置m34的值就可以了？</p>
<p>透视投影</p>
<pre><code>眼睛从实际平行的两条线段发出（相当于z轴方向的向量），人眼看起来会相交于一点上（焦点，Focal point），这才产生了3D感
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1716542-15471fcddd4ea19f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a7ed0efe4aebcddaef0d090c631b4.jpeg.png"></p>
<p>m34 = -1 / d (d值的是人眼到屏幕的距离,值一般在500 - 1000之间比较合适)；</p>
<p><a href="http://dreampiggy.com/2016/11/01/core-animation-3dfang-she-bian-huan-zhi-shi/" target="_blank" rel="external">Core Animation 3D仿射变换知识</a></p>
<h3 id="ios7之后提供的物理动效"><a href="#ios7之后提供的物理动效" class="headerlink" title="ios7之后提供的物理动效"></a>ios7之后提供的物理动效</h3><p>UIGravityBehavior 重力<br>UICollisionBehavior 碰撞<br>UISnapBehavior    吸附<br>UIPushBehavior    推力<br>UIAttachmentBehavior 关联</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="ZT0526">ZT0526</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
